"""Generated content entity.

Domain entity representing content that has been generated by a pipeline."""

from dataclasses import dataclass, field, replace as dataclass_replace
from datetime import datetime
from typing import Dict, Any, Optional, List, Self

from ..value_objects.content_id import ContentId
from ..value_objects.template_name import TemplateName
from ..value_objects.style_name import StyleName
from ..value_objects.content_type import ContentType
from ..value_objects.content_format import ContentFormat
from ..value_objects.content_length import ContentLength


@dataclass
class GeneratedContent:
    """Domain entity representing generated content.
    
    Generated content is the output of a pipeline execution, containing
    the final content along with metadata about how it was generated.
    This includes links to the template and style primer used, quality
    metrics, and version tracking.
    
    Examples:
        content = GeneratedContent.create(
            content_text="This is the generated article...",
            template_name=TemplateName.from_user_input("blog-post"),
            content_type=ContentType.blog_post(),
            format=ContentFormat.markdown()
        )
        
        content = content.add_quality_metric("readability_score", 8.5)
        content = content.set_approval_status("approved", "user@example.com")
    """
    
    id: ContentId
    content_text: str
    template_name: TemplateName
    content_type: ContentType
    format: ContentFormat
    title: Optional[str] = None
    summary: Optional[str] = None
    style_name: Optional[StyleName] = None
    word_count: int = 0
    character_count: int = 0
    content_length: Optional[ContentLength] = None
    
    # Generation metadata
    pipeline_run_id: Optional[str] = None
    step_count: int = 0
    total_generation_time_seconds: float = 0.0
    llm_model_used: Optional[str] = None
    total_tokens_used: int = 0
    generation_cost: float = 0.0
    
    # Quality and approval
    quality_metrics: Dict[str, Any] = field(default_factory=dict)
    approval_status: Optional[str] = None  # draft, under_review, approved, rejected
    approved_by: Optional[str] = None
    approved_at: Optional[datetime] = None
    feedback: List[str] = field(default_factory=list)
    
    # Versioning and tracking
    version: str = "1.0.0"
    revision_count: int = 0
    parent_content_id: Optional[ContentId] = None
    tags: List[str] = field(default_factory=list)
    
    # Timestamps
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    published_at: Optional[datetime] = None
    
    # Additional metadata
    author: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self) -> None:
        """Validate generated content entity."""
        if not isinstance(self.id, ContentId):
            raise TypeError("Generated content ID must be a ContentId")
            
        if not isinstance(self.template_name, TemplateName):
            raise TypeError("Template name must be a TemplateName")
            
        if not isinstance(self.content_type, ContentType):
            raise TypeError("Content type must be a ContentType")
            
        if not isinstance(self.format, ContentFormat):
            raise TypeError("Content format must be a ContentFormat")
            
        if not self.content_text or not self.content_text.strip():
            raise ValueError("Content text cannot be empty")
            
        if self.style_name is not None and not isinstance(self.style_name, StyleName):
            raise TypeError("Style name must be a StyleName")
            
        if self.content_length is not None and not isinstance(self.content_length, ContentLength):
            raise TypeError("Content length must be a ContentLength")
            
        # Calculate word and character counts if not provided
        if self.word_count == 0:
            self.word_count = len(self.content_text.split())
        if self.character_count == 0:
            self.character_count = len(self.content_text)
    
    def update_content(self, content_text: str, updated_by: Optional[str] = None) -> Self:
        """Update the content text and create a new revision.
        
        Args:
            content_text: New content text
            updated_by: User who made the update
            
        Returns:
            Updated content with new revision
        """
        if not content_text or not content_text.strip():
            raise ValueError("Content text cannot be empty")
            
        # Increment patch version
        version_parts = self.version.split('.')
        if len(version_parts) == 3:
            patch = int(version_parts[2]) + 1
            new_version = f"{version_parts[0]}.{version_parts[1]}.{patch}"
        else:
            new_version = f"{self.version}.1"
        
        return dataclass_replace(
            self,
            content_text=content_text,
            word_count=len(content_text.split()),
            character_count=len(content_text),
            version=new_version,
            revision_count=self.revision_count + 1,
            author=updated_by or self.author,
            updated_at=datetime.now(),
            approval_status="draft"  # Reset approval status on content change
        )
    
    def set_title(self, title: str) -> Self:
        """Set the content title.
        
        Args:
            title: Content title
            
        Returns:
            Updated content
        """
        if not title or not title.strip():
            raise ValueError("Title cannot be empty")
            
        return dataclass_replace(
            self,
            title=title.strip(),
            updated_at=datetime.now()
        )
    
    def set_summary(self, summary: str) -> Self:
        """Set the content summary.
        
        Args:
            summary: Content summary
            
        Returns:
            Updated content
        """
        if not summary or not summary.strip():
            raise ValueError("Summary cannot be empty")
            
        return dataclass_replace(
            self,
            summary=summary.strip(),
            updated_at=datetime.now()
        )
    
    def add_quality_metric(self, metric_name: str, value: Any) -> Self:
        """Add a quality metric.
        
        Args:
            metric_name: Name of the quality metric
            value: Metric value
            
        Returns:
            Updated content
        """
        if not metric_name or not metric_name.strip():
            raise ValueError("Metric name cannot be empty")
            
        new_metrics = self.quality_metrics.copy()
        new_metrics[metric_name] = value
        
        return dataclass_replace(
            self,
            quality_metrics=new_metrics,
            updated_at=datetime.now()
        )
    
    def set_approval_status(self, status: str, approved_by: Optional[str] = None) -> Self:
        """Set the approval status.
        
        Args:
            status: Approval status (draft, under_review, approved, rejected)
            approved_by: User who set the approval status
            
        Returns:
            Updated content
        """
        valid_statuses = {"draft", "under_review", "approved", "rejected"}
        if status not in valid_statuses:
            raise ValueError(f"Invalid approval status '{status}'. Valid statuses: {', '.join(sorted(valid_statuses))}")
        
        approved_at = datetime.now() if status in {"approved", "rejected"} else None
        
        return dataclass_replace(
            self,
            approval_status=status,
            approved_by=approved_by,
            approved_at=approved_at,
            updated_at=datetime.now()
        )
    
    def add_feedback(self, feedback: str, feedback_by: Optional[str] = None) -> Self:
        """Add feedback to the content.
        
        Args:
            feedback: Feedback text
            feedback_by: User who provided the feedback
            
        Returns:
            Updated content
        """
        if not feedback or not feedback.strip():
            raise ValueError("Feedback cannot be empty")
            
        feedback_entry = feedback.strip()
        if feedback_by:
            feedback_entry = f"[{feedback_by}] {feedback_entry}"
            
        new_feedback = self.feedback.copy()
        new_feedback.append(feedback_entry)
        
        return dataclass_replace(
            self,
            feedback=new_feedback,
            updated_at=datetime.now()
        )
    
    def add_tag(self, tag: str) -> Self:
        """Add a tag to the content.
        
        Args:
            tag: Tag to add
            
        Returns:
            Updated content
        """
        if not tag or not tag.strip():
            raise ValueError("Tag cannot be empty")
            
        normalized_tag = tag.strip().lower()
        if normalized_tag in self.tags:
            return self
            
        new_tags = self.tags.copy()
        new_tags.append(normalized_tag)
        
        return dataclass_replace(
            self,
            tags=new_tags,
            updated_at=datetime.now()
        )
    
    def remove_tag(self, tag: str) -> Self:
        """Remove a tag from the content.
        
        Args:
            tag: Tag to remove
            
        Returns:
            Updated content
        """
        normalized_tag = tag.strip().lower()
        if normalized_tag not in self.tags:
            return self
            
        new_tags = [t for t in self.tags if t != normalized_tag]
        
        return dataclass_replace(
            self,
            tags=new_tags,
            updated_at=datetime.now()
        )
    
    def set_generation_metadata(
        self,
        pipeline_run_id: Optional[str] = None,
        step_count: Optional[int] = None,
        generation_time: Optional[float] = None,
        model_used: Optional[str] = None,
        tokens_used: Optional[int] = None,
        cost: Optional[float] = None
    ) -> Self:
        """Set generation metadata.
        
        Args:
            pipeline_run_id: ID of the pipeline run that generated this content
            step_count: Number of steps in the pipeline
            generation_time: Total time taken to generate content (seconds)
            model_used: LLM model used for generation
            tokens_used: Total tokens consumed
            cost: Total cost of generation
            
        Returns:
            Updated content
        """
        return dataclass_replace(
            self,
            pipeline_run_id=pipeline_run_id or self.pipeline_run_id,
            step_count=step_count if step_count is not None else self.step_count,
            total_generation_time_seconds=generation_time if generation_time is not None else self.total_generation_time_seconds,
            llm_model_used=model_used or self.llm_model_used,
            total_tokens_used=tokens_used if tokens_used is not None else self.total_tokens_used,
            generation_cost=cost if cost is not None else self.generation_cost,
            updated_at=datetime.now()
        )
    
    def publish(self, published_by: Optional[str] = None) -> Self:
        """Publish the content.
        
        Args:
            published_by: User who published the content
            
        Returns:
            Updated content
        """
        if self.approval_status != "approved":
            raise ValueError("Content must be approved before publishing")
            
        return dataclass_replace(
            self,
            published_at=datetime.now(),
            author=published_by or self.author,
            updated_at=datetime.now()
        )
    
    def create_revision(self, content_text: str, revised_by: Optional[str] = None) -> Self:
        """Create a new revision of this content.
        
        Args:
            content_text: Updated content text
            revised_by: User who created the revision
            
        Returns:
            New content entity representing the revision
        """
        if not content_text or not content_text.strip():
            raise ValueError("Content text cannot be empty")
            
        return dataclass_replace(
            self,
            id=ContentId.generate(),  # New ID for the revision
            content_text=content_text,
            word_count=len(content_text.split()),
            character_count=len(content_text),
            parent_content_id=self.id,
            revision_count=self.revision_count + 1,
            author=revised_by or self.author,
            approval_status="draft",
            approved_by=None,
            approved_at=None,
            created_at=datetime.now(),
            updated_at=datetime.now(),
            published_at=None
        )
    
    def get_quality_score(self) -> Optional[float]:
        """Get the overall quality score if available.
        
        Returns:
            Quality score or None if not available
        """
        return self.quality_metrics.get("overall_score")
    
    def get_readability_score(self) -> Optional[float]:
        """Get the readability score if available.
        
        Returns:
            Readability score or None if not available
        """
        return self.quality_metrics.get("readability_score")
    
    def is_published(self) -> bool:
        """Check if the content is published.
        
        Returns:
            True if content is published
        """
        return self.published_at is not None
    
    def is_approved(self) -> bool:
        """Check if the content is approved.
        
        Returns:
            True if content is approved
        """
        return self.approval_status == "approved"
    
    def get_generation_efficiency(self) -> Optional[float]:
        """Calculate generation efficiency (words per second).
        
        Returns:
            Words per second or None if time not available
        """
        if self.total_generation_time_seconds <= 0:
            return None
        return self.word_count / self.total_generation_time_seconds
    
    def get_cost_per_word(self) -> Optional[float]:
        """Calculate cost per word.
        
        Returns:
            Cost per word or None if cost/word count not available
        """
        if self.word_count <= 0 or self.generation_cost <= 0:
            return None
        return self.generation_cost / self.word_count
    
    @classmethod
    def create(
        cls,
        content_text: str,
        template_name: TemplateName,
        content_type: ContentType,
        format: ContentFormat,
        title: Optional[str] = None,
        summary: Optional[str] = None,
        style_name: Optional[StyleName] = None,
        author: Optional[str] = None,
        pipeline_run_id: Optional[str] = None
    ) -> Self:
        """Create new generated content.
        
        Args:
            content_text: The generated content text
            template_name: Name of template used
            content_type: Type of content
            format: Content format
            title: Content title
            summary: Content summary
            style_name: Style primer used
            author: Content author
            pipeline_run_id: Pipeline run that generated this content
            
        Returns:
            New generated content instance
        """
        return cls(
            id=ContentId.generate(),
            content_text=content_text,
            template_name=template_name,
            content_type=content_type,
            format=format,
            title=title,
            summary=summary,
            style_name=style_name,
            word_count=len(content_text.split()),
            character_count=len(content_text),
            pipeline_run_id=pipeline_run_id,
            author=author,
            approval_status="draft",
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
    
    def __str__(self) -> str:
        """String representation."""
        status = self.approval_status or "draft"
        return f"GeneratedContent({self.template_name}, {self.word_count} words, {status})"
    
    def __repr__(self) -> str:
        """Debug representation."""
        return (f"GeneratedContent(id={self.id}, template={self.template_name}, "
                f"type={self.content_type}, words={self.word_count}, "
                f"status={self.approval_status}, created={self.created_at})")