"""Generated content repository interface.

Provides data access operations for generated content including
output storage, versioning, and content lifecycle management.
"""

from abc import abstractmethod
from datetime import datetime
from typing import List, Optional, Dict, Any
from uuid import UUID

from ....shared.repository import WorkspaceAwareRepository, Specification
from ....domains.workspace.value_objects.workspace_name import WorkspaceName
from ..entities.generated_content import GeneratedContent
from ..value_objects.content_id import ContentId
from ..value_objects.content_type import ContentType
from ..value_objects.content_format import ContentFormat
from ..value_objects.template_name import TemplateName
from ..value_objects.style_name import StyleName


class GeneratedContentRepository(WorkspaceAwareRepository[GeneratedContent]):
    """Repository for generated content persistence and retrieval.
    
    Handles CRUD operations for generated content with versioning,
    output management, and content lifecycle tracking.
    """
    
    @abstractmethod
    async def find_by_pipeline_run(
        self, 
        run_id: UUID
    ) -> List[GeneratedContent]:
        """Find all content generated by a pipeline run.
        
        Args:
            run_id: Pipeline run identifier
            
        Returns:
            List of generated content from the run
            
        Raises:
            RepositoryError: If query operation fails
        """
        pass
    
    @abstractmethod
    async def find_by_template(
        self, 
        template_name: TemplateName
    ) -> List[GeneratedContent]:
        """Find all content generated from a template.
        
        Args:
            template_name: Template name to filter by
            
        Returns:
            List of content generated from the template
            
        Raises:
            RepositoryError: If query operation fails
        """
        pass
    
    @abstractmethod
    async def find_by_style(
        self, 
        style_name: StyleName
    ) -> List[GeneratedContent]:
        """Find all content generated with a style primer.
        
        Args:
            style_name: Style name to filter by
            
        Returns:
            List of content generated with the style
            
        Raises:
            RepositoryError: If query operation fails
        """
        pass
    
    @abstractmethod
    async def find_by_content_type(
        self, 
        content_type: ContentType
    ) -> List[GeneratedContent]:
        """Find all content of a specific type.
        
        Args:
            content_type: Content type to filter by
            
        Returns:
            List of content with the type
            
        Raises:
            RepositoryError: If query operation fails
        """
        pass
    
    @abstractmethod
    async def find_by_format(
        self, 
        format: ContentFormat
    ) -> List[GeneratedContent]:
        """Find all content in a specific format.
        
        Args:
            format: Content format to filter by
            
        Returns:
            List of content in the format
            
        Raises:
            RepositoryError: If query operation fails
        """
        pass
    
    @abstractmethod
    async def find_recent_content(
        self, 
        limit: int = 20, 
        workspace: Optional[WorkspaceName] = None
    ) -> List[GeneratedContent]:
        """Find recently generated content.
        
        Args:
            limit: Maximum number of content items to return
            workspace: Optional workspace filter
            
        Returns:
            List of recent content, ordered by creation time desc
            
        Raises:
            RepositoryError: If query operation fails
        """
        pass
    
    @abstractmethod
    async def find_content_by_date_range(
        self, 
        start_date: datetime, 
        end_date: datetime
    ) -> List[GeneratedContent]:
        """Find content generated within a date range.
        
        Args:
            start_date: Start of date range (inclusive)
            end_date: End of date range (inclusive)
            
        Returns:
            List of content in the date range
            
        Raises:
            RepositoryError: If query operation fails
        """
        pass
    
    @abstractmethod
    async def search_content(
        self, 
        query: str, 
        search_metadata: bool = True
    ) -> List[GeneratedContent]:
        """Search content by text query.
        
        Args:
            query: Text to search for
            search_metadata: Whether to include metadata in search
            
        Returns:
            List of content matching the query
            
        Raises:
            RepositoryError: If search operation fails
        """
        pass
    
    @abstractmethod
    async def find_content_versions(
        self, 
        base_content: GeneratedContent
    ) -> List[GeneratedContent]:
        """Find all versions of content.
        
        Args:
            base_content: Base content to find versions for
            
        Returns:
            List of all content versions, ordered by version
            
        Raises:
            RepositoryError: If query operation fails
        """
        pass
    
    @abstractmethod
    async def get_latest_version(
        self, 
        content_family: str
    ) -> Optional[GeneratedContent]:
        """Get latest version of content family.
        
        Args:
            content_family: Content family identifier
            
        Returns:
            Latest version if found, None otherwise
            
        Raises:
            RepositoryError: If query operation fails
        """
        pass
    
    @abstractmethod
    async def store_content_file(
        self, 
        content: GeneratedContent, 
        file_data: bytes
    ) -> str:
        """Store content file data and return file path.
        
        Args:
            content: Content metadata
            file_data: File content as bytes
            
        Returns:
            File path where content was stored
            
        Raises:
            RepositoryError: If storage operation fails
        """
        pass
    
    @abstractmethod
    async def load_content_file(
        self, 
        content: GeneratedContent
    ) -> bytes:
        """Load content file data.
        
        Args:
            content: Content to load file for
            
        Returns:
            File content as bytes
            
        Raises:
            EntityNotFoundError: If content file not found
            RepositoryError: If loading operation fails
        """
        pass
    
    @abstractmethod
    async def get_content_stats(
        self, 
        workspace: Optional[WorkspaceName] = None
    ) -> Dict[str, Any]:
        """Get content generation statistics.
        
        Args:
            workspace: Optional workspace filter
            
        Returns:
            Dictionary with content statistics:
            - total_content: Total number of content items
            - content_by_type: Breakdown by content type
            - content_by_format: Breakdown by format
            - average_length: Average content length
            - generation_rate: Content per day
            
        Raises:
            RepositoryError: If stats calculation fails
        """
        pass
    
    @abstractmethod
    async def get_popular_templates(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get most frequently used templates.
        
        Args:
            limit: Maximum number of templates to return
            
        Returns:
            List of dictionaries with template usage statistics:
            - template_name: Template name
            - usage_count: Number of times used
            - last_used: Last usage timestamp
            - success_rate: Success percentage
            
        Raises:
            RepositoryError: If stats calculation fails
        """
        pass
    
    @abstractmethod
    async def get_popular_styles(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get most frequently used style primers.
        
        Args:
            limit: Maximum number of styles to return
            
        Returns:
            List of dictionaries with style usage statistics:
            - style_name: Style name
            - usage_count: Number of times used
            - last_used: Last usage timestamp
            - content_types: Content types used with
            
        Raises:
            RepositoryError: If stats calculation fails
        """
        pass
    
    @abstractmethod
    async def archive_old_content(
        self, 
        older_than: datetime, 
        keep_count: int = 100
    ) -> int:
        """Archive old generated content.
        
        Args:
            older_than: Archive content older than this date
            keep_count: Minimum number of content items to keep
            
        Returns:
            Number of content items archived
            
        Raises:
            RepositoryError: If archive operation fails
        """
        pass
    
    @abstractmethod
    async def export_content(
        self, 
        content: GeneratedContent, 
        export_format: str
    ) -> bytes:
        """Export content in specified format.
        
        Args:
            content: Content to export
            export_format: Target export format (pdf, docx, etc.)
            
        Returns:
            Exported content as bytes
            
        Raises:
            RepositoryError: If export operation fails
        """
        pass


# Specifications for generated content queries

class ByPipelineRunSpecification(Specification[GeneratedContent]):
    """Specification for filtering content by pipeline run."""
    
    def __init__(self, run_id: UUID):
        self.run_id = run_id
    
    def is_satisfied_by(self, content: GeneratedContent) -> bool:
        return content.pipeline_run_id == self.run_id


class ByTemplateSpecification(Specification[GeneratedContent]):
    """Specification for filtering content by template."""
    
    def __init__(self, template_name: TemplateName):
        self.template_name = template_name
    
    def is_satisfied_by(self, content: GeneratedContent) -> bool:
        return content.template_name == self.template_name


class ByStyleSpecification(Specification[GeneratedContent]):
    """Specification for filtering content by style."""
    
    def __init__(self, style_name: StyleName):
        self.style_name = style_name
    
    def is_satisfied_by(self, content: GeneratedContent) -> bool:
        return content.style_name == self.style_name


class ByContentTypeSpecification(Specification[GeneratedContent]):
    """Specification for filtering content by type."""
    
    def __init__(self, content_type: ContentType):
        self.content_type = content_type
    
    def is_satisfied_by(self, content: GeneratedContent) -> bool:
        return content.content_type == self.content_type


class ByFormatSpecification(Specification[GeneratedContent]):
    """Specification for filtering content by format."""
    
    def __init__(self, format: ContentFormat):
        self.format = format
    
    def is_satisfied_by(self, content: GeneratedContent) -> bool:
        return content.format == self.format


class DateRangeSpecification(Specification[GeneratedContent]):
    """Specification for filtering content by date range."""
    
    def __init__(self, start_date: datetime, end_date: datetime):
        self.start_date = start_date
        self.end_date = end_date
    
    def is_satisfied_by(self, content: GeneratedContent) -> bool:
        return (
            content.created_at is not None and
            self.start_date <= content.created_at <= self.end_date
        )


class RecentContentSpecification(Specification[GeneratedContent]):
    """Specification for filtering recent content."""
    
    def __init__(self, hours: int = 24):
        self.cutoff = datetime.now() - datetime.timedelta(hours=hours)
    
    def is_satisfied_by(self, content: GeneratedContent) -> bool:
        return (
            content.created_at is not None and
            content.created_at >= self.cutoff
        )
