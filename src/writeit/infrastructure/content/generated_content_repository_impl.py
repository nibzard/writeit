"""LMDB implementation of GeneratedContentRepository.

Provides concrete LMDB-backed storage for generated content with
workspace isolation and content management capabilities.
"""

from typing import List, Optional, Any
from datetime import datetime, timedelta

from ...domains.content.repositories.generated_content_repository import GeneratedContentRepository
from ...domains.content.entities.generated_content import GeneratedContent
from ...domains.content.value_objects.content_id import ContentId
from ...domains.content.value_objects.content_type import ContentType
from ...domains.content.value_objects.content_format import ContentFormat
from ...domains.workspace.value_objects.workspace_name import WorkspaceName
from ...shared.repository import RepositoryError, EntityNotFoundError
from ..base.repository_base import LMDBRepositoryBase
from ..base.storage_manager import LMDBStorageManager
from ..base.serialization import DomainEntitySerializer


class LMDBGeneratedContentRepository(LMDBRepositoryBase[GeneratedContent], GeneratedContentRepository):
    """LMDB implementation of GeneratedContentRepository.
    
    Stores generated content with workspace isolation and provides
    comprehensive content management capabilities.
    """
    
    def __init__(
        self, 
        storage_manager: LMDBStorageManager,
        workspace_name: WorkspaceName
    ):
        """Initialize repository.
        
        Args:
            storage_manager: LMDB storage manager
            workspace_name: Workspace for data isolation
        """
        super().__init__(
            storage_manager=storage_manager,
            workspace_name=workspace_name,
            entity_type=GeneratedContent,
            db_name="generated_content",
            db_key="content"
        )
    
    def _setup_serializer(self, serializer: DomainEntitySerializer) -> None:
        """Setup serializer with generated content-specific types."""
        serializer.register_value_object(ContentId)
        serializer.register_value_object(ContentType)
        serializer.register_value_object(ContentFormat)
        serializer.register_value_object(WorkspaceName)
        serializer.register_type("GeneratedContent", GeneratedContent)
    
    def _get_entity_id(self, entity: GeneratedContent) -> Any:
        """Extract entity ID for storage key."""
        return entity.id
    
    def _make_storage_key(self, entity_id: Any) -> str:
        """Create storage key from entity ID."""
        workspace_prefix = self._get_workspace_prefix()
        if isinstance(entity_id, ContentId):
            return f"{workspace_prefix}content:{entity_id.value}"
        else:
            return f"{workspace_prefix}content:{str(entity_id)}"
    
    async def find_by_pipeline_run(self, run_id: str) -> List[GeneratedContent]:
        """Find content generated by a specific pipeline run."""
        all_content = await self.find_by_workspace()
        return [c for c in all_content if c.pipeline_run_id == run_id]
    
    async def find_by_content_type(self, content_type: ContentType) -> List[GeneratedContent]:
        """Find content by content type."""
        all_content = await self.find_by_workspace()
        return [c for c in all_content if c.content_type == content_type]
    
    async def find_recent_content(self, days: int = 7) -> List[GeneratedContent]:
        """Find recently generated content."""
        since = datetime.now() - timedelta(days=days)
        all_content = await self.find_by_workspace()
        recent = [c for c in all_content if c.created_at >= since]
        recent.sort(key=lambda c: c.created_at, reverse=True)
        return recent
    
    async def find_by_template(self, template_id: str) -> List[GeneratedContent]:
        """Find content generated from a specific template."""
        all_content = await self.find_by_workspace()
        return [c for c in all_content if c.template_id == template_id]
    
    async def search_content(self, query: str) -> List[GeneratedContent]:
        """Search generated content by text query."""
        all_content = await self.find_by_workspace()
        query_lower = query.lower()
        
        return [
            content for content in all_content
            if (query_lower in content.title.lower() if content.title else False) or
               (query_lower in content.content.lower()) or
               any(query_lower in tag.lower() for tag in content.tags)
        ]
    
    async def get_content_statistics(self) -> dict:
        """Get content generation statistics."""
        all_content = await self.find_by_workspace()
        
        if not all_content:
            return {
                "total_content": 0,
                "content_types": {},
                "avg_word_count": 0,
                "total_generations": 0
            }
        
        # Count by content type
        content_types = {}
        total_words = 0
        
        for content in all_content:
            content_type = str(content.content_type)
            content_types[content_type] = content_types.get(content_type, 0) + 1
            
            if content.word_count:
                total_words += content.word_count
        
        return {
            "total_content": len(all_content),
            "content_types": content_types,
            "avg_word_count": total_words / len(all_content) if all_content else 0,
            "total_generations": len(all_content)
        }
    
    async def cleanup_old_content(self, older_than_days: int = 90) -> int:
        """Clean up old generated content."""
        cutoff_date = datetime.now() - timedelta(days=older_than_days)
        all_content = await self.find_by_workspace()
        
        old_content = [c for c in all_content if c.created_at < cutoff_date]
        
        deleted_count = 0
        for content in old_content:
            if await self.delete_by_id(content.id):
                deleted_count += 1
        
        return deleted_count